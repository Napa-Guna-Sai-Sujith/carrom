<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŽ¯ Pro Carrom Master</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @keyframes pulse-glow {
            0%,
            100% {
                text-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
            }
            50% {
                text-shadow: 0 0 20px rgba(255, 235, 59, 1);
            }
        }
        
        @keyframes slide-in {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes bounce-score {
            0%,
            100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.15);
            }
        }
        
        body {
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        
        #game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            gap: 15px;
        }
        
        canvas {
            box-shadow: 0 0 60px rgba(255, 235, 59, 0.3), 0 0 100px rgba(0, 0, 0, 0.8);
            border: 18px solid #5d4037;
            border-radius: 12px;
            cursor: crosshair;
            transition: box-shadow 0.3s;
        }
        
        canvas:hover {
            box-shadow: 0 0 80px rgba(255, 235, 59, 0.5), 0 0 120px rgba(0, 0, 0, 0.9);
        }
        
        .stats-panel {
            position: absolute;
            top: 25px;
            left: 25px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 20, 40, 0.9) 100%);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #d4af37;
            backdrop-filter: blur(10px);
            animation: slide-in 0.5s ease-out;
        }
        
        .stats-panel h2 {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .turn-indicator {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            animation: pulse-glow 2s infinite;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .p1-color {
            color: #f5f5f5;
            text-shadow: 0 0 15px rgba(245, 245, 245, 0.5);
        }
        
        .p2-color {
            color: #424242;
            text-shadow: 0 0 15px rgba(66, 66, 66, 0.5);
        }
        
        .score-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 10px;
        }
        
        .score-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            transition: all 0.3s;
        }
        
        .score-box:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #d4af37;
        }
        
        .score-box p:first-child {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: #888;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        
        .score-box p:last-child {
            font-size: 2.5rem;
            font-weight: bold;
            animation: bounce-score 0.6s ease-in-out;
        }
        
        .score-box:nth-child(1) p:last-child {
            color: #f5f5f5;
        }
        
        .score-box:nth-child(2) p:last-child {
            color: #888;
        }
        
        #queen-status {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(233, 30, 99, 0.1);
            border: 1px solid rgba(233, 30, 99, 0.5);
            border-radius: 6px;
            font-size: 0.8rem;
            text-align: center;
            color: #ff4081;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            animation: pulse-glow 2s infinite;
        }
        
        .stats-panel.game-active {
            border-color: #ff6b9d;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            text-align: center;
            color: #aaa;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
        
        #instructions span {
            color: #ffd700;
            font-weight: bold;
        }
        
        #message-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            padding: 35px 55px;
            border-radius: 25px;
            text-align: center;
            display: none;
            z-index: 999;
            border: 3px solid #d4af37;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.5);
            animation: slide-in 0.3s ease-out;
        }
        
        #overlay-title {
            font-size: 2.2rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(255, 235, 59, 0.5);
        }
        
        #overlay-msg {
            font-size: 1.1rem;
            color: #e0e0e0;
            line-height: 1.6;
        }
        
        #reset-btn,
        #undo-btn,
        #stats-btn {
            position: absolute;
            bottom: 20px;
            padding: 10px 18px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 2px solid;
            font-size: 0.85rem;
        }
        
        #reset-btn {
            right: 20px;
            background: linear-gradient(135deg, #d32f2f 0%, #c62828 100%);
            color: white;
            border-color: #ff6f6f;
            box-shadow: 0 4px 15px rgba(211, 47, 47, 0.4);
        }
        
        #reset-btn:hover {
            background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%);
            box-shadow: 0 6px 20px rgba(211, 47, 47, 0.6);
            transform: translateY(-2px);
        }
        
        #undo-btn {
            right: 140px;
            background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
            color: white;
            border-color: #42a5f5;
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.4);
        }
        
        #undo-btn:hover {
            background: linear-gradient(135deg, #42a5f5 0%, #1976d2 100%);
            box-shadow: 0 6px 20px rgba(25, 118, 210, 0.6);
            transform: translateY(-2px);
        }
        
        #stats-btn {
            right: 260px;
            background: linear-gradient(135deg, #f57c00 0%, #e65100 100%);
            color: white;
            border-color: #ffb74d;
            box-shadow: 0 4px 15px rgba(245, 124, 0, 0.4);
        }
        
        #stats-btn:hover {
            background: linear-gradient(135deg, #ffb74d 0%, #f57c00 100%);
            box-shadow: 0 6px 20px rgba(245, 124, 0, 0.6);
            transform: translateY(-2px);
        }
        
        .top-info {
            position: absolute;
            top: 25px;
            right: 25px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid #d4af37;
            text-align: right;
            font-size: 0.9rem;
            animation: slide-in 0.5s ease-out;
        }
        
        .top-info p {
            margin: 5px 0;
            color: #aaa;
        }
        
        .top-info span {
            color: #ffd700;
            font-weight: bold;
        }
        
        #stats-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            padding: 40px;
            border-radius: 20px;
            z-index: 1000;
            display: none;
            border: 3px solid #d4af37;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }
        
        #stats-modal h2 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid rgba(212, 175, 55, 0.3);
            margin-bottom: 8px;
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #888;
            font-weight: 500;
        }
        
        .stat-value {
            color: #ffd700;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        #close-stats {
            display: block;
            margin: 20px auto 0;
            padding: 10px 25px;
            background: linear-gradient(135deg, #d32f2f 0%, #c62828 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.3s;
        }
        
        #close-stats:hover {
            background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%);
            transform: scale(1.05);
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
            display: none;
        }
        
        .modal-overlay.active {
            display: block;
        }
        
        .combo-indicator {
            position: absolute;
            top: 150px;
            right: 25px;
            background: rgba(255, 235, 59, 0.1);
            border: 2px solid #ffd700;
            padding: 12px 18px;
            border-radius: 10px;
            color: #ffd700;
            font-weight: bold;
            text-align: center;
            display: none;
        }
        
        .combo-indicator.active {
            display: block;
            animation: pulse-glow 1s infinite;
        }
    </style>
</head>

<body>

    <div class="modal-overlay" id="modal-overlay"></div>

    <div id="game-container">
        <div class="stats-panel" id="stats-panel">
            <h2>ðŸŽ¯ Carrom Master</h2>
            <div id="turn-display" class="turn-indicator p1-color">Player 1's Turn (White)</div>

            <div class="score-container">
                <div class="score-box">
                    <p>Player 1 (White)</p>
                    <p id="p1-score">0</p>
                </div>
                <div class="score-box">
                    <p>Player 2 (Black)</p>
                    <p id="p2-score">0</p>
                </div>
            </div>

            <div id="queen-status">Queen: On Board</div>
        </div>

        <div class="top-info">
            <p>White Pieces: <span id="white-count">9</span></p>
            <p>Black Pieces: <span id="black-count">9</span></p>
            <p>Turns Played: <span id="turn-count">0</span></p>
        </div>

        <canvas id="carromBoard" width="600" height="600"></canvas>

        <div id="message-overlay">
            <h2 id="overlay-title" class="text-2xl font-bold mb-2"></h2>
            <p id="overlay-msg" class="text-lg"></p>
        </div>

        <div class="combo-indicator" id="combo-indicator">
            <div id="combo-text">COMBO!</div>
        </div>

        <div id="instructions">
            <span>Step 1:</span> Drag Striker to position &nbsp; | &nbsp; <span>Step 2:</span> Drag back to Aim & Fire!
        </div>

        <button id="stats-btn" title="View Game Statistics">ðŸ“Š Stats</button>
        <button id="undo-btn" title="Undo Last Move">â†¶ Undo</button>
        <button id="reset-btn" title="Reset Game">ðŸ”„ Reset</button>
    </div>

    <div id="stats-modal">
        <h2>ðŸ“ˆ Game Statistics</h2>
        <div class="stat-row">
            <span class="stat-label">Player 1 Score:</span>
            <span class="stat-value" id="stat-p1-score">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Player 2 Score:</span>
            <span class="stat-value" id="stat-p2-score">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Turns Played:</span>
            <span class="stat-value" id="stat-turns">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">White Pocketed:</span>
            <span class="stat-value" id="stat-white">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Black Pocketed:</span>
            <span class="stat-value" id="stat-black">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Queen Status:</span>
            <span class="stat-value" id="stat-queen">On Board</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Lead:</span>
            <span class="stat-value" id="stat-lead">Tied</span>
        </div>
        <button id="close-stats">Close</button>
    </div>

    <script>
        const canvas = document.getElementById('carromBoard');
        const ctx = canvas.getContext('2d');
        const p1ScoreEl = document.getElementById('p1-score');
        const p2ScoreEl = document.getElementById('p2-score');
        const turnDisplay = document.getElementById('turn-display');
        const queenStatusEl = document.getElementById('queen-status');
        const messageOverlay = document.getElementById('message-overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayMsg = document.getElementById('overlay-msg');
        const resetBtn = document.getElementById('reset-btn');
        const undoBtn = document.getElementById('undo-btn');
        const statsBtn = document.getElementById('stats-btn');
        const statsModal = document.getElementById('stats-modal');
        const closeStatsBtn = document.getElementById('close-stats');
        const modalOverlay = document.getElementById('modal-overlay');
        const comboIndicator = document.getElementById('combo-indicator');
        const whiteCountEl = document.getElementById('white-count');
        const blackCountEl = document.getElementById('black-count');
        const turnCountEl = document.getElementById('turn-count');

        // Constants
        const BOARD_SIZE = 600;
        const POCKET_RADIUS = 35;
        const FRICTION = 0.985;
        const STRIKER_RADIUS = 20;
        const PIECE_RADIUS = 14;
        const WALL_BOUNCE = 0.75;
        const BASELINE_Y_P1 = 480;
        const BASELINE_Y_P2 = 120;
        const BASELINE_MARGIN = 60;

        // Game State
        let currentPlayer = 1;
        let p1Score = 0;
        let p2Score = 0;
        let pieces = [];
        let striker;
        let isDragging = false;
        let isPositioning = true;
        let dragStart = {
            x: 0,
            y: 0
        };
        let dragCurrent = {
            x: 0,
            y: 0
        };
        let moving = false;
        let queenPocketedBy = null;
        let queenWaitingForCover = false;
        let piecesPocketedThisTurn = [];
        let turnCount = 0;
        let consecutiveHits = 0;
        let gameHistory = [];
        let whitePocketed = 0;
        let blackPocketed = 0;

        class Piece {
            constructor(x, y, radius, type, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.type = type;
                this.color = color;
                this.vx = 0;
                this.vy = 0;
                this.mass = type === 'striker' ? 2 : 1;
                this.inPocket = false;
                this.originalX = x;
                this.originalY = y;
            }

            draw() {
                if (this.inPocket) return;

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                ctx.lineWidth = 2;
                ctx.stroke();

                if (this.type === 'striker') {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (this.type === 'queen') {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(233, 30, 99, 0.3)';
                    ctx.fill();
                    ctx.strokeStyle = '#e91e63';
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            update() {
                if (this.inPocket) return;

                this.x += this.vx;
                this.y += this.vy;

                this.vx *= FRICTION;
                this.vy *= FRICTION;

                if (Math.abs(this.vx) < 0.1) this.vx = 0;
                if (Math.abs(this.vy) < 0.1) this.vy = 0;

                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx = -this.vx * WALL_BOUNCE;
                } else if (this.x + this.radius > BOARD_SIZE) {
                    this.x = BOARD_SIZE - this.radius;
                    this.vx = -this.vx * WALL_BOUNCE;
                }

                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy = -this.vy * WALL_BOUNCE;
                } else if (this.y + this.radius > BOARD_SIZE) {
                    this.y = BOARD_SIZE - this.radius;
                    this.vy = -this.vy * WALL_BOUNCE;
                }

                const corners = [{
                    x: 0,
                    y: 0
                }, {
                    x: BOARD_SIZE,
                    y: 0
                }, {
                    x: 0,
                    y: BOARD_SIZE
                }, {
                    x: BOARD_SIZE,
                    y: BOARD_SIZE
                }];

                corners.forEach(corner => {
                    const dist = Math.hypot(this.x - corner.x, this.y - corner.y);
                    if (dist < POCKET_RADIUS) {
                        this.pocket();
                    }
                });
            }

            pocket() {
                this.inPocket = true;
                this.vx = 0;
                this.vy = 0;
                piecesPocketedThisTurn.push(this);
            }
        }

        function initBoard() {
            pieces = [];
            const centerX = BOARD_SIZE / 2;
            const centerY = BOARD_SIZE / 2;

            pieces.push(new Piece(centerX, centerY, PIECE_RADIUS, 'queen', '#e91e63'));

            for (let i = 0; i < 6; i++) {
                const angle = (i * 60) * Math.PI / 180;
                const dist = PIECE_RADIUS * 2.1;
                const type = i % 2 === 0 ? 'white' : 'black';
                const color = type === 'white' ? '#f5f5f5' : '#333';
                pieces.push(new Piece(centerX + Math.cos(angle) * dist, centerY + Math.sin(angle) * dist, PIECE_RADIUS, type, color));
            }

            for (let i = 0; i < 12; i++) {
                const angle = (i * 30) * Math.PI / 180;
                const dist = PIECE_RADIUS * 4.2;
                const type = (i % 2 === 0) ? 'white' : 'black';
                const color = type === 'white' ? '#f5f5f5' : '#333';
                pieces.push(new Piece(centerX + Math.cos(angle) * dist, centerY + Math.sin(angle) * dist, PIECE_RADIUS, type, color));
            }

            resetStriker();
            updateStats();
        }

        function resetStriker() {
            const y = currentPlayer === 1 ? BASELINE_Y_P1 : BASELINE_Y_P2;
            striker = new Piece(BOARD_SIZE / 2, y, STRIKER_RADIUS, 'striker', '#ffeb3b');
            isPositioning = true;
            isDragging = false;
            moving = false;
        }

        function saveGameState() {
            gameHistory.push({
                p1Score: p1Score,
                p2Score: p2Score,
                currentPlayer: currentPlayer,
                pieces: pieces.map(p => ({
                    x: p.x,
                    y: p.y,
                    type: p.type,
                    inPocket: p.inPocket
                })),
                striker: {
                    x: striker.x,
                    y: striker.y
                },
                queenPocketedBy: queenPocketedBy,
                queenWaitingForCover: queenWaitingForCover,
                whitePocketed: whitePocketed,
                blackPocketed: blackPocketed
            });
        }

        function undoMove() {
            if (gameHistory.length === 0) {
                showMessage("CANNOT UNDO", "No moves to undo!");
                return;
            }

            const state = gameHistory.pop();
            p1Score = state.p1Score;
            p2Score = state.p2Score;
            currentPlayer = state.currentPlayer;
            queenPocketedBy = state.queenPocketedBy;
            queenWaitingForCover = state.queenWaitingForCover;
            whitePocketed = state.whitePocketed;
            blackPocketed = state.blackPocketed;

            state.pieces.forEach((pData, idx) => {
                pieces[idx].x = pData.x;
                pieces[idx].y = pData.y;
                pieces[idx].inPocket = pData.inPocket;
            });

            striker.x = state.striker.x;
            striker.y = state.striker.y;

            p1ScoreEl.innerText = p1Score;
            p2ScoreEl.innerText = p2Score;
            updateTurnDisplay();
            updateStats();
            showMessage("MOVE UNDONE", "Last move has been reversed!");
        }

        function drawBoardDesign() {
            ctx.fillStyle = '#f3e5ab';
            ctx.fillRect(0, 0, BOARD_SIZE, BOARD_SIZE);

            ctx.fillStyle = '#111';
            [
                [0, 0],
                [BOARD_SIZE, 0],
                [0, BOARD_SIZE],
                [BOARD_SIZE, BOARD_SIZE]
            ].forEach(p => {
                ctx.beginPath();
                ctx.arc(p[0], p[1], POCKET_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 2;

            [BASELINE_Y_P1, BASELINE_Y_P2].forEach(y => {
                ctx.beginPath();
                ctx.moveTo(BASELINE_MARGIN, y - STRIKER_RADIUS);
                ctx.lineTo(BOARD_SIZE - BASELINE_MARGIN, y - STRIKER_RADIUS);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(BASELINE_MARGIN, y + STRIKER_RADIUS);
                ctx.lineTo(BOARD_SIZE - BASELINE_MARGIN, y + STRIKER_RADIUS);
                ctx.stroke();
            });

            [BASELINE_MARGIN, BOARD_SIZE - BASELINE_MARGIN].forEach(x => {
                [BASELINE_Y_P1, BASELINE_Y_P2].forEach(y => {
                    ctx.beginPath();
                    ctx.arc(x, y, STRIKER_RADIUS, 0, Math.PI * 2);
                    ctx.stroke();
                });
            });

            ctx.beginPath();
            ctx.arc(BOARD_SIZE / 2, BOARD_SIZE / 2, PIECE_RADIUS * 1.2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(BOARD_SIZE / 2, BOARD_SIZE / 2, PIECE_RADIUS * 4.5, 0, Math.PI * 2);
            ctx.stroke();

            ctx.setLineDash([5, 15]);
            [
                [0, 0],
                [BOARD_SIZE, 0],
                [0, BOARD_SIZE],
                [BOARD_SIZE, BOARD_SIZE]
            ].forEach(p => {
                ctx.beginPath();
                ctx.moveTo(BOARD_SIZE / 2, BOARD_SIZE / 2);
                ctx.lineTo(p[0], p[1]);
                ctx.stroke();
            });
            ctx.setLineDash([]);
        }

        function resolveCollisions() {
            const all = [...pieces, striker].filter(p => !p.inPocket);
            for (let i = 0; i < all.length; i++) {
                for (let j = i + 1; j < all.length; j++) {
                    const p1 = all[i];
                    const p2 = all[j];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distance = Math.hypot(dx, dy);
                    const minDist = p1.radius + p2.radius;

                    if (distance < minDist) {
                        const angle = Math.atan2(dy, dx);
                        const targetX = p1.x + Math.cos(angle) * minDist;
                        const targetY = p1.y + Math.sin(angle) * minDist;
                        const ax = (targetX - p2.x) * 0.5;
                        const ay = (targetY - p2.y) * 0.5;

                        p1.x -= ax;
                        p1.y -= ay;
                        p2.x += ax;
                        p2.y += ay;

                        const nx = dx / distance;
                        const ny = dy / distance;
                        const p = 2 * (p1.vx * nx + p1.vy * ny - p2.vx * nx - p2.vy * ny) / (p1.mass + p2.mass);

                        p1.vx -= p * p2.mass * nx;
                        p1.vy -= p * p2.mass * ny;
                        p2.vx += p * p1.mass * nx;
                        p2.vy += p * p1.mass * ny;

                        if (p1.type === 'striker' || p2.type === 'striker') {
                            consecutiveHits++;
                            if (consecutiveHits >= 3) {
                                comboIndicator.classList.add('active');
                                setTimeout(() => comboIndicator.classList.remove('active'), 1000);
                            }
                        }
                    }
                }
            }
        }

        function update() {
            if (!moving) return;

            let stillMoving = false;
            const all = [striker, ...pieces];

            all.forEach(p => {
                if (!p.inPocket) {
                    p.update();
                    if (Math.abs(p.vx) > 0 || Math.abs(p.vy) > 0) {
                        stillMoving = true;
                    }
                }
            });

            resolveCollisions();

            if (!stillMoving) {
                moving = false;
                handleTurnEnd();
            }
        }

        function handleTurnEnd() {
            saveGameState();
            let turnContinues = false;
            let p1Gained = 0;
            let p2Gained = 0;
            let queenThisTurn = false;

            piecesPocketedThisTurn.forEach(p => {
                if (p.type === 'white') {
                    p1Gained += 20;
                    whitePocketed++;
                    if (currentPlayer === 1) turnContinues = true;
                } else if (p.type === 'black') {
                    p2Gained += 10;
                    blackPocketed++;
                    if (currentPlayer === 2) turnContinues = true;
                } else if (p.type === 'queen') {
                    queenThisTurn = true;
                    queenPocketedBy = currentPlayer;
                    queenWaitingForCover = true;
                    queenStatusEl.innerText = `Queen: Captured by P${currentPlayer} (Pending Cover)`;
                    turnContinues = true;
                } else if (p.type === 'striker') {
                    if (currentPlayer === 1) p1Score = Math.max(0, p1Score - 10);
                    else p2Score = Math.max(0, p2Score - 10);
                    showMessage("FOUL!", "Striker pocketed. -10 points.");
                    turnContinues = false;
                    consecutiveHits = 0;
                }
            });

            if (queenWaitingForCover && !queenThisTurn) {
                const covered = piecesPocketedThisTurn.some(p =>
                    (currentPlayer === 1 && p.type === 'white') ||
                    (currentPlayer === 2 && p.type === 'black')
                );

                if (covered) {
                    const bonus = 50;
                    if (currentPlayer === 1) p1Score += bonus;
                    else p2Score += bonus;
                    queenWaitingForCover = false;
                    queenStatusEl.innerText = `Queen: Captured by P${queenPocketedBy}`;
                    showMessage("QUEEN COVERED!", `+50 points for Player ${currentPlayer}`);
                    turnContinues = true;
                } else {
                    queenWaitingForCover = false;
                    queenPocketedBy = null;
                    queenStatusEl.innerText = `Queen: On Board (Returned)`;
                    const queen = pieces.find(p => p.type === 'queen');
                    queen.inPocket = false;
                    queen.x = BOARD_SIZE / 2;
                    queen.y = BOARD_SIZE / 2;
                    queen.vx = 0;
                    queen.vy = 0;
                    showMessage("COVER FAILED", "Queen returns to center.");
                    turnContinues = false;
                }
            }

            p1Score += p1Gained;
            p2Score += p2Gained;
            p1ScoreEl.innerText = p1Score;
            p2ScoreEl.innerText = p2Score;

            piecesPocketedThisTurn = [];

            if (!turnContinues) {
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                consecutiveHits = 0;
                turnCount++;
            }

            updateTurnDisplay();
            checkWin();
            resetStriker();
            updateStats();
        }

        function updateTurnDisplay() {
            turnDisplay.innerText = `Player ${currentPlayer}'s Turn (${currentPlayer === 1 ? 'White' : 'Black'})`;
            turnDisplay.className = `turn-indicator ${currentPlayer === 1 ? 'p1-color' : 'p2-color'}`;
        }

        function updateStats() {
            turnCountEl.innerText = turnCount;
            whiteCountEl.innerText = pieces.filter(p => p.type === 'white' && !p.inPocket).length;
            blackCountEl.innerText = pieces.filter(p => p.type === 'black' && !p.inPocket).length;

            document.getElementById('stat-p1-score').innerText = p1Score;
            document.getElementById('stat-p2-score').innerText = p2Score;
            document.getElementById('stat-turns').innerText = turnCount;
            document.getElementById('stat-white').innerText = whitePocketed;
            document.getElementById('stat-black').innerText = blackPocketed;
            document.getElementById('stat-queen').innerText = queenPocketedBy ? `Captured by P${queenPocketedBy}` : 'On Board';

            const diff = Math.abs(p1Score - p2Score);
            if (p1Score > p2Score) {
                document.getElementById('stat-lead').innerText = `P1 by ${diff}`;
            } else if (p2Score > p1Score) {
                document.getElementById('stat-lead').innerText = `P2 by ${diff}`;
            } else {
                document.getElementById('stat-lead').innerText = 'Tied';
            }
        }

        function showMessage(title, msg) {
            overlayTitle.innerText = title;
            overlayMsg.innerText = msg;
            messageOverlay.style.display = 'block';
            setTimeout(() => {
                messageOverlay.style.display = 'none';
            }, 2500);
        }

        function checkWin() {
            const remaining = pieces.filter(p => !p.inPocket && p.type !== 'striker');
            if (remaining.length === 0 || (remaining.length === 1 && remaining[0].type === 'queen' && queenPocketedBy)) {
                const winner = p1Score > p2Score ? "ðŸ† Player 1 Wins!" : (p2Score > p1Score ? "ðŸ† Player 2 Wins!" : "ðŸ¤ It's a Draw!");
                showMessage("GAME OVER", winner + ` | Final Score: P1: ${p1Score} | P2: ${p2Score}`);
                setTimeout(() => {
                    resetBtn.click();
                }, 5000);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, BOARD_SIZE, BOARD_SIZE);
            drawBoardDesign();

            pieces.forEach(p => p.draw());
            if (striker) {
                striker.draw();

                if (isPositioning && !moving) {
                    ctx.strokeStyle = '#fff';
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(striker.x, striker.y, striker.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.fillStyle = '#ffeb3b';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('POSITIONING', striker.x, striker.y - 35);
                }
            }

            if (isDragging && !moving && !isPositioning) {
                const dx = dragStart.x - dragCurrent.x;
                const dy = dragStart.y - dragCurrent.y;
                const dist = Math.hypot(dx, dy);

                ctx.beginPath();
                ctx.moveTo(striker.x, striker.y);
                ctx.lineTo(dragCurrent.x, dragCurrent.y);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.beginPath();
                ctx.moveTo(striker.x, striker.y);
                ctx.lineTo(striker.x + dx, striker.y + dy);
                ctx.strokeStyle = `rgb(255, ${Math.max(0, 255 - dist * 1.5)}, 0)`;
                ctx.lineWidth = 5;
                ctx.stroke();

                ctx.fillStyle = '#ffeb3b';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Power: ${Math.floor(dist / 3)}`, striker.x, striker.y + 40);
            }

            update();
            requestAnimationFrame(draw);
        }

        resetBtn.addEventListener('click', () => {
            p1Score = 0;
            p2Score = 0;
            p1ScoreEl.innerText = '0';
            p2ScoreEl.innerText = '0';
            currentPlayer = 1;
            queenPocketedBy = null;
            queenWaitingForCover = false;
            queenStatusEl.innerText = 'Queen: On Board';
            turnCount = 0;
            consecutiveHits = 0;
            gameHistory = [];
            whitePocketed = 0;
            blackPocketed = 0;
            initBoard();
            updateTurnDisplay();
            updateStats();
            showMessage("GAME RESET", "ðŸŽ® New game started!");
        });

        undoBtn.addEventListener('click', undoMove);

        statsBtn.addEventListener('click', () => {
            statsModal.style.display = 'block';
            modalOverlay.classList.add('active');
            updateStats();
        });

        closeStatsBtn.addEventListener('click', () => {
            statsModal.style.display = 'none';
            modalOverlay.classList.remove('active');
        });

        modalOverlay.addEventListener('click', () => {
            statsModal.style.display = 'none';
            modalOverlay.classList.remove('active');
        });

        canvas.addEventListener('mousedown', e => {
            if (moving) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const dist = Math.hypot(x - striker.x, y - striker.y);
            if (dist < striker.radius * 2) {
                isDragging = true;
                dragStart = {
                    x,
                    y
                };
                dragCurrent = {
                    x,
                    y
                };
            }
        });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isDragging) {
                if (isPositioning) {
                    const minX = BASELINE_MARGIN;
                    const maxX = BOARD_SIZE - BASELINE_MARGIN;
                    striker.x = Math.max(minX, Math.min(maxX, x));
                } else {
                    dragCurrent = {
                        x,
                        y
                    };
                }
            }
        });

        canvas.addEventListener('mouseup', e => {
            if (!isDragging) return;

            if (isPositioning) {
                isPositioning = false;
            } else {
                const dx = dragStart.x - dragCurrent.x;
                const dy = dragStart.y - dragCurrent.y;
                const power = Math.hypot(dx, dy) * 0.15;
                const angle = Math.atan2(dy, dx);

                if (power > 0.5) {
                    striker.vx = Math.cos(angle) * Math.min(power, 25);
                    striker.vy = Math.sin(angle) * Math.min(power, 25);
                    moving = true;
                }
            }
            isDragging = false;
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            const dist = Math.hypot(x - striker.x, y - striker.y);
            if (dist < striker.radius * 3) {
                isDragging = true;
                dragStart = {
                    x,
                    y
                };
                dragCurrent = {
                    x,
                    y
                };
            }
        }, {
            passive: false
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            if (isDragging) {
                if (isPositioning) {
                    const minX = BASELINE_MARGIN;
                    const maxX = BOARD_SIZE - BASELINE_MARGIN;
                    striker.x = Math.max(minX, Math.min(maxX, x));
                } else {
                    dragCurrent = {
                        x,
                        y
                    };
                }
            }
        }, {
            passive: false
        });

        canvas.addEventListener('touchend', e => {
            if (!isDragging) return;
            if (isPositioning) {
                isPositioning = false;
            } else {
                const dx = dragStart.x - dragCurrent.x;
                const dy = dragStart.y - dragCurrent.y;
                const power = Math.hypot(dx, dy) * 0.15;
                const angle = Math.atan2(dy, dx);

                if (power > 0.5) {
                    striker.vx = Math.cos(angle) * Math.min(power, 25);
                    striker.vy = Math.sin(angle) * Math.min(power, 25);
                    moving = true;
                }
            }
            isDragging = false;
        });

        initBoard();
        updateTurnDisplay();
        draw();
    </script>
</body>

</html>